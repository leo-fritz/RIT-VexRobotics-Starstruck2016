#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Yaw,            sensorGyro)
#pragma config(Sensor, dgtl1,  ScissorTop,     sensorTouch)
#pragma config(Sensor, dgtl2,  ScissorBottom,  sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           Lift1,         tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           FrontLeft,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port3,           BackLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           Scissor1,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           Scissor2,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           Scissor3,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           Scissor4,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           BackRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           FrontRight,    tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          Lift2,         tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "vex_competition_includes.c"
int ChoiceArray[1];
int DegreeArray[1];
int SpeedArray[1];
int AutoStep = 0;
int Leftspeed, Rightspeed;
bool firing, driving, turning, run;

float gyroBias(long totalBias =0)
{
	SensorType[Yaw] = sensorNone;
	for(int i=0; i<2000; i++)
	{
		totalBias += SensorValue[Yaw];
	}
	SensorType[Yaw] = sensorGyro;
	return totalBias/2000;
}

int limit(int input, int min, int max)//Tynan
{
	input = input<=max?input:max;
	input = input>=min?input:min;
	return input;
}

void pre_auton()
{
	SensorBias[Yaw] = gyroBias();
}

void motorspeed(string *motorgroup, int speed)//motorgoup is the word, speed is a value
{
	switch(strIndex(*motorgroup, 0))
	{
		case 'r'://call with motorspeed("right", speed);
		motor[BackRight] = speed;//Insert mootors for the right drive here
		motor[FrontRight] = speed;
		break;

		case 'l'://call with motorspeed("left", speed)
		motor[FrontLeft] = speed;//insert motors for the left drive here
		motor[BackLeft] = speed;
		break;

		case 's'://call with motorspeed("height", speed)
		motor[Scissor1] = speed;//insert scissor lift motors here
		motor[Scissor2] = speed;
		motor[Scissor3] = speed;
		motor[Scissor4] = speed;
		break;

		default:
		motor[Lift1] = speed;//insert motors for the lift here
		motor[Lift2] = speed;
		break;
	}
}

void fire()
{
	motorspeed("scissor", 127);
	waitUntil(SensorValue[ScissorTop]==1);
	motorspeed("scissor", 0);
	wait1Msec(75);
	motorspeed("scissor", -127);
	waitUntil(SensorValue[ScissorBottom]==1);
	motorspeed("scissor", 0);
}

void drive(int distance, int speed, int error = 10)
{
	resetMotorEncoder(FrontLeft);
  resetMotorEncoder(FrontRight);
  Rightspeed = speed;
  Leftspeed = speed;
	do
	{
		motorspeed("left", Leftspeed);
		motorspeed("right", Rightspeed);
		if(getMotorEncoder(FrontLeft)>getMotorEncoder(FrontRight))
		{
			if(Rightspeed<speed)
				Rightspeed++;
			else
				Leftspeed--;
		}
		else
		{
			if(Leftspeed<speed)
				Leftspeed++;
			else
				Rightspeed--;
		}
	}while(abs(getMotorEncoder(FrontLeft)-distance)>error);
	motorspeed("left", 0);
	motorspeed("right", 0);
}

void turn(int angle, int speed, int error = 7)
{
	SensorValue[Yaw] = 0;
	Rightspeed = speed;
  Leftspeed = -speed;
  do
  {
		motorspeed("left", Leftspeed);
		motorspeed("right", Rightspeed);
		if(getMotorEncoder(FrontLeft)>getMotorEncoder(FrontRight))
		{
			if(Rightspeed<speed)
				Rightspeed++;
			else
				Leftspeed++;
		}
		else
		{
			if(Leftspeed> -speed)
				Leftspeed--;
			else
				Rightspeed--;
		}
  }while(angle - SensorValue[Yaw]>error);
  motorspeed("left", 0);
	motorspeed("right", 0);
}

void AutoFunction(int choice, int degree, int speed)//Gabe
{
	if(choice == 1)//Firing
	{
		fire();
		waitUntil(firing == false);
	}
	else if(choice == 2)//Driving
	{
		drive(degree, speed);
		waitUntil(driving == false);
	}
	else//Turning
	{
		turn(degree, speed);
		waitUntil(turning == false);
	}
}

task autonomous()
{
	while(true)
	{
		AutoFunction(ChoiceArray[AutoStep], DegreeArray[AutoStep], SpeedArray[AutoStep]);
		waitUntil(run == false);
		AutoStep++;
		AutoStep = limit(AutoStep, 0 , 17);
	}
}

task usercontrol()
{
	while(true)
	{
		motorspeed("left", vexRT[Ch2]);
		motorspeed("right", vexRT[Ch3]);
		motorspeed("scissor", vexRT[Btn5U]*127-vexRT[Btn5D]*127);
		motorspeed("poles", vexRT[Btn6U]*127-vexRT[Btn6D]*127);
	}
}
